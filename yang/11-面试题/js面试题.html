<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		
			1.var、let、const 的区别?
		
			var 声明的变量有变量提升的特性，而 let、const 没有
			var 声明的变量会挂载到 windows 对象上，所以使用 var 声明的是全局变量，而 let 和 const 声明的变量是局部变量, 块级作用域外不能访问
			同一作用域下 let 和 const 不能重复声明同名变量，而var可以
			const声明的是常量，必须赋初值，一旦声明不能再次赋值修改，如果声明的是复合类型数据，可以修改其属性
		
		
		
		
		
			2.js中的基础数据类型有哪几种? 
			
			Javascript数据类型分为基本数据类型与引用数据类型，其中基本数据类型为：
			字符串（String）、数字(Number)、布尔(Boolean)、、空值（Null）、未定义（Undefined）、symbol。
			引用数据，类型为对象(Object)，其中数组(Array)、函数（function）是一种特殊的对象。
		
		
		
		
		
		
			3.input事件和change事件的区别
			
			input事件：输输入框内容发生改变时就会触发
			change事件：输入框内容发生改变，并且输入框失去焦点时触发。
		
		
		
		
			4. 变量 函数提升
			
			console.log(a); //undefined
			var a = 6; 
			
			js引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到到代码头部
			只有function声明的函数会发生函数名提升，而如果通过赋值语句写的函数则不会。
			
			fn(); //a
			function fn (){
				console.log("a");
			}
		
			
			
		
		
			5. 函数默认参数 
			
			function fn(param = 'hello') {
			    console.log(param);
			}
			方法被调用时，如果没有给参数赋值，那就是用默认值；
			方法被调用时，如果给参数赋值了新的值，那就用新的值。
			默认值的后面，不能再有没有默认值的变量。比如(a,b,c)这三个参数，如果我给 b 设置了默认值，那么就一定要给 c 设置默认值。
			
			
		
			
			
			
			
			6. 解构赋值
			
			1.解构对象
			const a = {
			      name: 'name',
			      age: 18,
			      marriage: false,
			    }
			let { name, age, marriage} = a;
			console.log(name, age, marriage)  打印信息：name 18 false
			
			2.解构数组
			let arr = [1,2,3];
			let [a,b,c] = arr;
			console.log(a); // 1
			
			
			
			
			
			
			
			
			
			
			7. 深拷贝，浅拷贝
			
			拷贝的时候并没有给b创造独立的内存，只是把a指向数据的 指针 拷贝给了b！
			
			原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。
			这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。
			这是因为 JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，不能接受函数。
			let objnew = JSON.parse(JSON.stringify(obj))
			
			//递归来实现深拷贝
			function deepClone(obj) {
				var newObj = obj instanceof Array ? [] : {};
				if (typeof obj !== 'object') {
					return obj;
				} else {
					for (var i in obj) {
						newObj[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
					}
				}
				return newObj;
			}
			var objnew = deepClone(obj)
			console.log(objnew)
				
				
				
				
				
				
				
			8. 扩展运算符
			
			let a = ["Bill","Mary","Lucy"];
			let b = [21,24,27];
			let c = [...a,...b];
			console.log(c);  // [ 'Bill', 'Mary', 'Lucy', 21, 24, 27 ]
			
			
			
			
			
			
			9. 类数组是什么和数组有什么区别
			
			相同点:都具有length属性和索引元素 
			不同点:类数组没有任何Array属性和Array方法(比如push)”
			let arr = document.querySelectorAll("div") 取到的是一个类数组 
			console.log(arr instanceof Array) 返回false
			Array.isArray(arr) 判断是不是数组返回false
			
			
			
			
			
			
			
			
			
			
			10. this的指向和 call与apply和bind区别
			https://blog.csdn.net/zwt13976124194/article/details/123384413
			
			1. 在普通函数中调用就是window
			window.username='程新松'
			function fn(){
			    console.log(this.username);
			}
			fn(); //程新松
			
		
			
			2. 对象里的this 哪个函数调用，this指向哪里。
			
			指向调用函数的那个对象 例如arr调用了a这个函数 this就是arr
			var arr = {
				b: 'ddd',
				a() {
					console.log(this.b)
				},	
			}
			arr.a();  //ddd
			
			
			
			3.箭头函数调用
			let obj={
			    name:'程新松',
			    fn:function(){
			        setTimeout(function(){console.log(this.name)})
			    }
			}
			obj.fn();
			不难发现，虽然 fn() 里面的 this 是指向 obj ，但是，传给 setTimeout 的是普通函数，
			this 指向是 window ， window 下面没有 name ，所以这里输出 underfind 。
			
			如果换成箭头函数
			这次输出 程新松 是因为，传给 setTimeout 的是箭头函数，然后箭头函数里面没有 this ，
			所以要向上层作用域查找，在这个例子上， setTimeout 的上层作用域是 fn 。而 fn 里面的 this 指向 obj ，
			所以 setTimeout 里面的箭头函数的 this ，指向 obj 。所以输出 程新松。
			
			
			
			
			4. call与apply和bind
			var a = {
			    user:"用户a",
			    fn:function(){
			        console.log(this.user); 
			    }
			}
			var b = {
				   user:"用户b"
			};
			
			a.fn.call(b);  //用户b
			把a对象里面的fn函数的指向 改成了b 
			 
			 a.fn.call(b,1,2); call里面还可以传别的参数 
			 a.fn.call(b,[1,2]);  apply其他参数必须是一个数组
			
			
			
			
			
			
			11. arguments
			arguments 是一个对应于传递给函数的参数的类数组对象 里面包含了函数所有的实参
			
			
			
			
			
			
			12. 防抖节流 
			https://www.lodashjs.com/
			函数防抖： 防抖就是回城被打断就要重来 
			将几次操作合并为一次操作进行。原理是维护一个定时器，规定在延迟时间后触发函数，只有最后一次操作能被触发。
			防抖:search联想搜索，用户在不断输入内容的时候，用防抖来节约请求资源。window触发resize时候，不断调整浏览器窗口大小会不断的触发这个事件，用防抖让其只触发一次。
			
			
			函数节流： 节流就是cd  cd没好 用不了技能
			使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。
			节流：鼠标不断点击（mousedown）触发，让其单位时间内只触发一次。
			
			
			
			13. 闭包
			
			
			
			
			5. 如何优化内存泄漏?
			
			  全局变量先声明在使用
			  避免过多使用闭包。
			  注意清除定时器和事件监听器。
			  
			  
			  
			构造函数和函数的区别 实例化对象是什么意思
			原型链 显示原型和隐式原型 
			
			
			
			
			
			
			
				promise async await then 方法
				js继承
				
				数组的方法 那些方法改变原数组 filter  concat 改7个 
				math. 随机数
				
				
				session cookies token 
				跨域问题
				递归
				
				  
				  //阻止冒泡
				  e.stopPropagation();
				  //阻止默认行为
				  e.preventDefault();
				  
				  
				  //截取				
				  slice 				
				  //拆分
				  split
				  
				  
				  substring
				  
				  		
				  diff算法
				  
				  indexOf检索  
				  "abcd".indexOf('') = 0
				  
				  
				  forEach遍历数组给数组添加新的key值等于原有的key
				  
				  
				  
				
		
		
		https://blog.csdn.net/m0_65450343/article/details/124658549
		https://blog.csdn.net/Amrice_/article/details/123086495
		https://wenku.baidu.com/view/c09d3d42834d2b160b4e767f5acfa1c7aa008282.html
		
		
		
		
		
	</body>
</html>