<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		
			1.var、let、const 的区别?
		
			var 声明的变量有变量提升的特性，而 let、const 没有
			var 声明的变量会挂载到 windows 对象上，所以使用 var 声明的是全局变量，而 let 和 const 声明的变量是局部变量, 块级作用域外不能访问
			同一作用域下 let 和 const 不能重复声明同名变量，而var可以
			const声明的是常量，必须赋初值，一旦声明不能再次赋值修改，如果声明的是复合类型数据，可以修改其属性
		
		
		
		
		
			2.js中的基础数据类型有哪几种? 
			
			Javascript数据类型分为基本数据类型与引用数据类型，其中基本数据类型为：
			字符串（String）、数字(Number)、布尔(Boolean)、、空值（Null）、未定义（Undefined）、symbol。
			引用数据，类型为对象(Object)，其中数组(Array)、函数（function）是一种特殊的对象。
		
		
		
		
		
		
			3.input事件和change事件的区别
			
			input事件：输输入框内容发生改变时就会触发
			change事件：输入框内容发生改变，并且输入框失去焦点时触发。
		
		
		
		
			4. 变量 函数提升
			
			console.log(a); //undefined
			var a = 6; 
			
			js引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到到代码头部
			只有function声明的函数会发生函数名提升，而如果通过赋值语句写的函数则不会。
			
			fn(); //a
			function fn (){
				console.log("a");
			}
		
			
			
		
		
			5. 函数默认参数 
			
			function fn(param = 'hello') {
			    console.log(param);
			}
			方法被调用时，如果没有给参数赋值，那就是用默认值；
			方法被调用时，如果给参数赋值了新的值，那就用新的值。
			默认值的后面，不能再有没有默认值的变量。比如(a,b,c)这三个参数，如果我给 b 设置了默认值，那么就一定要给 c 设置默认值。
			
			
		
			
			
			
			
			6. 解构赋值
			
			1.解构对象
			const a = {
			      name: 'name',
			      age: 18,
			      marriage: false,
			    }
			let { name, age, marriage} = a;
			console.log(name, age, marriage)  打印信息：name 18 false
			
			2.解构数组
			let arr = [1,2,3];
			let [a,b,c] = arr;
			console.log(a); // 1
			
			
			
			
			
			
			
			
			
			
			7. 深拷贝，浅拷贝
			
			拷贝的时候并没有给b创造独立的内存，只是把a指向数据的 指针 拷贝给了b！
			
			原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。
			这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。
			这是因为 JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，不能接受函数。
			let objnew = JSON.parse(JSON.stringify(obj))
			
			//递归来实现深拷贝
			function deepClone(obj) {
				var newObj = obj instanceof Array ? [] : {};
				if (typeof obj !== 'object') {
					return obj;
				} else {
					for (var i in obj) {
						newObj[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
					}
				}
				return newObj;
			}
			var objnew = deepClone(obj)
			console.log(objnew)
				
				
				
				
				
				
				
			8. 扩展运算符
			
			let a = ["Bill","Mary","Lucy"];
			let b = [21,24,27];
			let c = [...a,...b];
			console.log(c);  // [ 'Bill', 'Mary', 'Lucy', 21, 24, 27 ]
			
			
			
			
			
			
			9. 类数组是什么和数组有什么区别
			
			相同点:都具有length属性和索引元素 
			不同点:类数组没有任何Array属性和Array方法(比如push)”
			let arr = document.querySelectorAll("div") 取到的是一个类数组 
			console.log(arr instanceof Array) 返回false
			Array.isArray(arr) 判断是不是数组返回false
			
			
			
			
			
			
			
			
			
			
			10. this的指向和 call与apply和bind区别
			https://blog.csdn.net/zwt13976124194/article/details/123384413
			
			1. 在普通函数中调用就是window
			window.username='程新松'
			function fn(){
			    console.log(this.username);
			}
			fn(); //程新松
			
		
			
			2. 对象里的this 哪个函数调用，this指向哪里。
			
			指向调用函数的那个对象 例如arr调用了a这个函数 this就是arr
			var arr = {
				b: 'ddd',
				a() {
					console.log(this.b)
				},	
			}
			arr.a();  //ddd
			
			
			
			3.箭头函数调用
			let obj={
			    name:'程新松',
			    fn:function(){
			        setTimeout(function(){console.log(this.name)})
			    }
			}
			obj.fn();
			不难发现，虽然 fn() 里面的 this 是指向 obj ，但是，传给 setTimeout 的是普通函数，
			this 指向是 window ， window 下面没有 name ，所以这里输出 underfind 。
			
			如果换成箭头函数
			这次输出 程新松 是因为，传给 setTimeout 的是箭头函数，然后箭头函数里面没有 this ，
			所以要向上层作用域查找，在这个例子上， setTimeout 的上层作用域是 fn 。而 fn 里面的 this 指向 obj ，
			所以 setTimeout 里面的箭头函数的 this ，指向 obj 。所以输出 程新松。
			
			
			
			
			4. call与apply和bind
			var a = {
			    user:"用户a",
			    fn:function(){
			        console.log(this.user); 
			    }
			}
			var b = {
				   user:"用户b"
			};
			
			a.fn.call(b);  //用户b
			把a对象里面的fn函数的指向 改成了b 
			 
			 a.fn.call(b,1,2); call里面还可以传别的参数 
			 a.fn.call(b,[1,2]);  apply其他参数必须是一个数组
			
			
			
			
			
			
			11. arguments
			arguments 是一个对应于传递给函数的参数的类数组对象 里面包含了函数所有的实参
			
			
			
			
			
			
			12. 防抖节流 
			https://www.lodashjs.com/
			函数防抖： 防抖就是回城被打断就要重来 
			将几次操作合并为一次操作进行。原理是维护一个定时器，规定在延迟时间后触发函数，只有最后一次操作能被触发。
			防抖:search联想搜索，用户在不断输入内容的时候，用防抖来节约请求资源。window触发resize时候，不断调整浏览器窗口大小会不断的触发这个事件，用防抖让其只触发一次。
			
			
			函数节流： 节流就是cd  cd没好 用不了技能
			使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。
			节流：鼠标不断点击（mousedown）触发，让其单位时间内只触发一次。
			
			
			
			13. 闭包
			
			//什么是闭包
			//闭包是嵌套的内部函数
			
			//产生闭包的条件
			//函数嵌套 内部函数引用了外部函数的变量 并且执行外部函数
			
			//闭包的作用
			//使函数内部的变量在函数执行完 没有消失 仍然存在
			//让函数外部 可以操作函数内部的数据
			
			function fun1() {         //外部函数fun1
				var a = 1;           //外部函数里有个变量 a=1
				function fun2() {    //内部函数 fun2
					console.log(a--) //内部函数里面用了外部函数的变量并且减1
				}
				return fun2           //外部函数的返回值是未执行的内部函数
			}
			
			
			var aaa = fun1(); //调用外部函数 获取外部函数的返回值并且存在aaa  此时的aaa就是内部函数 
			aaa(); //第一次调用内部函数
			aaa(); //第二次调用内部函数
			
			
			
			
			14. 如何优化内存泄漏?
			
			  全局变量先声明在使用
			  避免过多使用闭包。
			  注意清除定时器和事件监听器。
			  
			  
			  
			15. 构造函数和普通函数的区别 
			
				构造函数习惯上首字母大写
				构造函数用来新建实例对象
				a. 普通函数的调用方式：直接调用 person();
				b.构造函数的调用方式：需要使用new关键字来调用 new Person();
			
			
			
			
			
			
			
			16. 原型链 显示原型和隐式原型 
			
				1、所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）。
				2、所有的引用类型都有一个’_ _ proto_ _'属性(也叫隐式原型，它是一个普通的对象)。
				3、所有的函数都有一个’prototype’属性(这也叫显式原型，它也是一个普通的对象)。
				4、所有引用类型，它的’_ _ proto_ _'属性指向它的构造函数的’prototype’属性。
				5、当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _'属性(也就是它的构造函数的’prototype’属性)中去寻找。
		
			
				// 定义一个构造函数
				function Person(name,age){
					this.name = name;
					this.age = age;
				}
				
				// 创建一个构造函数的实例对象
				let person = new Person("张三",18)
				
				//构造函数的显示原型属性 拿到原型对象
				// console.log(Person.prototype) 
				
				//实例身上的隐式原型属性 拿到原型对象
				// console.log(person.__proto__)
				
				//通过显示原型属性往原型对象身上加一个x值是99
				Person.prototype.x = 99
				//person的原型对象身上就会有x这个属性
				console.log(person)
			
			
			
				17. promise async await
					
					1. promise是什么？
					Promise是JS中进行异步编程的新解决方案(ES6规范)
					Promise通过链式调用的解决方案，解决回调地狱问题
					
					2. Promise的状态有哪些?
					pendding(初始化状态，表示未发生改变)
					fulfilled(成功的状态）
					reject（失败的状态
					
					3. promise的状态和结果
					[[PromiseState]]: "fulfilled"
					[[PromiseResult]]: undefined

					
					4. 如何改变Promise状态?
					调用resolve或reject，每个Promise的状态只能修改一次
					
					5. 如何指定回调?
					首先获取promise实例对象，调用实例对象身上的.then()函数，并传入两个函数，
					第一个是成功的回调(resolve调用时执行)，第二个是失败的的回调(reject调用时执行)。 
					then可以只指定成功的回调，如果只指定失败的回调的话使用.catch(()=>{})其中传入失败的回调
					
					6. 如何执行回调?promise状态改变,即resolve或reject调用的时候自动执行
					
					Promise.resolve(value) 如果value是一个非Promise对象，则函数返回值是一个Promise对象，结果为value
					如果value是一个Promise对象，则返回值就是该Promise对象
					
					Promise.reject(reason) 返回一个失败的Promise对象，结果为reason
					
					Promise.all(promises) 返回一个新的promise，promises是一个包含多个promise的数组，
					当所有promise状态都为resolved，返回的promise状态才为resolved，状态为rejected
					
					Promise.race（promises） 返回一个新的promise，promises是一个包含多个promise的数组，
					只要有其中一个promise先改变状态，其状态就是返回的promise的状态，其结果就是返回的promise的结果。
					
					// 1.被async修饰过的函数 他的返回值就会是一个promise对象
					// 如果没有返回值就是fulfilled  
					// 如果返回的是一个字符串或者数字 这个函数的返回值就是promise对象 状态是成功 值就是这个函数的返回值
					// 如果返回的是一个promise对象 这个函数的返回值就是promise对象 状态是返回promise对象的状态 值就是这个是返回promise对象的值 throw也是一样
					
					// await 就是对右侧promise对象结果的一个获取
					// 如果右侧是一个数字或者字符串 结果就是对应的数字或字符串
					// 如果右侧是一个成功的promise对象 那么结果就是这个右侧promise对象的结果
					// 如果右侧是一个失败的promise对象 需要用try catch 里面的catch 来捕获这个promise对象失败的结果值
					
				
				
				18. session cookies token 
				
				
				
				
				跨域问题
				递归
				
				
				
				
				
				数组的方法 那些方法改变原数组 filter  concat 改7个 
				math. 随机数
				
				
				
				
				
				  
				  //阻止冒泡
				  e.stopPropagation();
				  //阻止默认行为
				  e.preventDefault();
				  
				  
				  //截取				
				  slice 				
				  //拆分
				  split
				  
				  
				  substring
				  
				  		
				  diff算法
				  
				  indexOf检索  
				  "abcd".indexOf('') = 0
				  
				  
				  forEach遍历数组给数组添加新的key值等于原有的key
				  
				  
				  
				
		
		
		https://blog.csdn.net/m0_65450343/article/details/124658549
		https://blog.csdn.net/Amrice_/article/details/123086495
		https://wenku.baidu.com/view/c09d3d42834d2b160b4e767f5acfa1c7aa008282.html
		
		
		
		
		
	</body>
</html>