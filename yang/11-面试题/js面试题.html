<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		
			1.var、let、const 的区别?
		
			var 声明的变量有变量提升的特性，而 let、const 没有
			var 声明的变量会挂载到 windows 对象上，所以使用 var 声明的是全局变量，而 let 和 const 声明的变量是局部变量, 块级作用域外不能访问
			同一作用域下 let 和 const 不能重复声明同名变量，而var可以
			const声明的是常量，必须赋初值，一旦声明不能再次赋值修改，如果声明的是复合类型数据，可以修改其属性
		
		
		
		
		
			2.js中的基础数据类型有哪几种? 
			
			Javascript数据类型分为基本数据类型与引用数据类型，其中基本数据类型为：
			字符串（String）、数字(Number)、布尔(Boolean)、、空值（Null）、未定义（Undefined）、symbol。
			引用数据，类型为对象(Object)，其中数组(Array)、函数（function）是一种特殊的对象。
		
		
		
		
		
		
			3.input事件和change事件的区别
			
			input事件：输输入框内容发生改变时就会触发
			change事件：输入框内容发生改变，并且输入框失去焦点时触发。
		
		
		
		
			4. 变量 函数提升
			
			console.log(a); //undefined
			var a = 6; 
			
			js引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到到代码头部
			只有function声明的函数会发生函数名提升，而如果通过赋值语句写的函数则不会。
			
			fn(); //a
			function fn (){
				console.log("a");
			}
		
			
			
		
		
			5. 函数默认参数 
			
			function fn(param = 'hello') {
			    console.log(param);
			}
			方法被调用时，如果没有给参数赋值，那就是用默认值；
			方法被调用时，如果给参数赋值了新的值，那就用新的值。
			默认值的后面，不能再有没有默认值的变量。比如(a,b,c)这三个参数，如果我给 b 设置了默认值，那么就一定要给 c 设置默认值。
			
			
		
			
			
			
			
			6. 解构赋值
			
			1.解构对象
			const a = {
			      name: 'name',
			      age: 18,
			      marriage: false,
			    }
			let { name, age, marriage} = a;
			console.log(name, age, marriage)  打印信息：name 18 false
			
			2.解构数组
			let arr = [1,2,3];
			let [a,b,c] = arr;
			console.log(a); // 1
			
			
			
			
			
			
			
			
			
			
			7. 深拷贝，浅拷贝
			
			拷贝的时候并没有给b创造独立的内存，只是把a指向数据的 指针 拷贝给了b！
			
			原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。
			这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。
			这是因为 JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，不能接受函数。
			let objnew = JSON.parse(JSON.stringify(obj))
			
			//递归来实现深拷贝
			function deepClone(obj) {
				var newObj = obj instanceof Array ? [] : {};
				if (typeof obj !== 'object') {
					return obj;
				} else {
					for (var i in obj) {
						newObj[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
					}
				}
				return newObj;
			}
			var objnew = deepClone(obj)
			console.log(objnew)
				
				
				
				
				
				
				
			8. 扩展运算符
			
			let a = ["Bill","Mary","Lucy"];
			let b = [21,24,27];
			let c = [...a,...b];
			console.log(c);  // [ 'Bill', 'Mary', 'Lucy', 21, 24, 27 ]
			
			
			
			
			
			
			9. 类数组
			
			console.log(Array.isArray())
			
			
			Array.from(item).forEach((item)=>{
			    console.log(item)
			})
			
			
			
			
			9. this的指向
			https://www.cnblogs.com/chengxs/p/8679313.html
			
			
			
			
			
			
			
			
			
				迭代器
				生成器
				iterator接口
				promise async await then 方法
				js继承
				
				防抖节流 
				
				
				数组的方法 那些方法改变原数组 filter  concat 改7个 
				math. 随机数
				构造函数和函数的区别 实例化对象是什么意思
				原型链 显示原型和隐式原型 
				闭包
				session cookies token 
				跨域问题
				递归
				5. 如何优化内存泄漏?
				
				  全局变量先声明在使用
				  避免过多使用闭包。
				  注意清除定时器和事件监听器。
				  
				  //阻止冒泡
				  e.stopPropagation();
				  //阻止默认行为
				  e.preventDefault();
				  
				  
				  //截取				
				  slice 				
				  //拆分
				  split
				  
				  
				  substring
				  
				  		
				  diff算法
				  
				  indexOf检索  
				  "abcd".indexOf('') = 0
				  
				  
				  forEach遍历数组给数组添加新的key值等于原有的key
				  
				  
				  
				
		
		
		https://blog.csdn.net/m0_65450343/article/details/124658549
		https://blog.csdn.net/Amrice_/article/details/123086495
		https://wenku.baidu.com/view/c09d3d42834d2b160b4e767f5acfa1c7aa008282.html
		
		
		
		
		
		//let 特性
			//1. 不能重复声明
			//2. 块级作用域 for if{}
			//3. 不存在变量提升
			//遍历练习用let
			/*window.onload = function(){
				let items = document.querySelectorAll(".item");
				for(let i=0;i<items.length;i++){
					items[i].onclick = function(){
						//this.style.backgroundColor = "white";
						items[i].style.backgroundColor = "white";
					}
				}	
			}*/
			
			
			
			//const特性 
			// 1. 必须附初始值_要不报错
			// 2. 全大写 
			// 3. 定义的之不能修改_要不报错
			// 4. 也是块级作用域
			// 5. 对数组和对象进行修改 不算修改 不会报错 因为地址值没有改变
			/*const BTN = ["aaa","bbb"]
			BTN.push("ccc");//不会报错
			BTN = 100;//会报错*/
			
			
			
			
			
			
			//解构赋值
			/*let fun = {
				name:"赵本山",
				xiaopin:function(){
					console.log("昨天 今天 明天");
				}
			}
			let {xiaopin} = fun;
			xiaopin();*/
			
			
			
			
			
			
			//模板字符串``
			/*1. 字符串拼接用${}
			2. 可以换行
			3. 用esc下面的反引号*/
			/*let aa = `哈哈`;
			let bb = `${aa}嘿
			嘿`;
			console.log(bb);*/
			
			
			
			
			
			
			
			//es6允许在大括号里面写入变量和函数 作为对象的属性和方法
			/*let aaa = "aaa";
			function bbb(){
				console.log("bbb");
			}
			var ccc = {
				//等同于aaa:aaa,
				aaa,
				bbb,
				//等同于ddd:function(){}
				ddd(){
					console.log("ddd")
				}
			}
			ccc.ddd();*/
			
			
			
			
			
			
			
			//箭头函数
			/*
			1. this是静态的 始终指向函数声明时所在作用域下的this的值
			2. 不能作为构造函数进行实例化对象
			3. 不能使用arguments_打印实参用的
			4. 箭头函数简写 形参只有一个的时候 形参的小括号可以不写
				let aaa = a =>{
					return a+a;
				}
				console.log(aaa(1))
				
			5. 当函数体只有一条执行语句的时候 可以省略花括号 return也必须省略
				此时语句的执行结果就是函数的返回值
				let aaa = a => a+a;
				console.log(aaa(1))
			*/
			/*let aaa = (a) => {
				return a+a;
			};
			console.log(aaa(1))*/
			
			
			
			
			//es6新增原始数据类型 symbol
			// let s = Symbol("haha");
			// let s1 = Symbol("haha")
			// console.log(s == s1)
			
			
			//尚硅谷晓飞老师的promise
			/*let p = new Promise((resolve,reject)=>{
				setTimeout(()=>{
					resolve("用户数据")
				},1000)
			})
			
		let result = p.then(value=>{
				console.log(value)
			},reason=>{
				console.warn(reason)
			})
			
			console.log(result)*/
			
			
			//set 集合 会自动去重
			/*let s = new Set();
			let s2 = new Set(["1","2","3","4","4"]);
			//新增
			s2.add("6")
			//查看数量
			console.log(s2.size)
			//遍历
			for(let v of s2){
				console.log(v)
			}
			//删除
			s2.delete("1")
			//清空
			s2.clear();
			//判断有没有
			console.log(s2.has("3"))
			console.log(s2)*/
			
			
			
			
			//数组去重
			 /*let arr = [1,2,3,4,5,5,3,6];
			 //使用扩展运算符
			let arr1 = [...new Set(arr)];
			 console.log(arr1)*/
		
	</body>
</html>