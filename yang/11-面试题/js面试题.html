<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		
				1.var、let、const 的区别?
				2.js中的基础数据类型有哪几种? 
				3.input事件和change事件的区别
				4. 变量 函数提升
				5. 函数默认参数
				6. 解构赋值
				7. 深拷贝，浅拷贝
				8. 扩展运算符
				9. 类数组是什么和数组有什么区别
				10. this的指向和 call与apply和bind区别
				11. arguments
				12. 防抖节流
				13. 闭包
				14. 如何优化内存泄漏?
				15. 构造函数和普通函数的区别
				16. 原型链 显示原型和隐式原型
				17. promise async await
				18. localStorage与sessionStorage cookies token
				19. 跨域问题
				20. 递归
				21. 随机数
				22. 事件对象
				23. 字符串方法
				24. 数组方法
				25. 数组的遍历
				26. 对象方法 | 遍历
				27. 什么是作用域，什么是作用域链？
				28.如何去判断js数据类型？
				29.js中的堆内存与栈内存
				30.js获取浏览器所用的内核
				31.null undefiend NaN的区别
				32.DOM事件流和事件委托？
				33.ajax是什么？以及如何去创建它？
				34.同步和异步的区别，分别列举一个同步和异步的例子？
				35.什么是宏任务和微任务，两者有什么区别？
				36. new一个实例的过程
				
				
		
		
		
			1.var、let、const 的区别?
		
			var 声明的变量有变量提升的特性，而 let、const 没有
			var 声明的变量会挂载到 windows 对象上，所以使用 var 声明的是全局变量，而 let 和 const 声明的变量是局部变量, 块级作用域外不能访问
			同一作用域下 let 和 const 不能重复声明同名变量，而var可以
			const声明的是常量，必须赋初值，一旦声明不能再次赋值修改，如果声明的是复合类型数据，可以修改其属性
		
		
		
		
		
			2.js中的基础数据类型有哪几种? 
			
			Javascript数据类型分为基本数据类型与引用数据类型，其中基本数据类型为：
			字符串（String）、数字(Number)、布尔(Boolean)、、空值（Null）、未定义（Undefined）、symbol。
			引用数据，类型为对象(Object)，其中数组(Array)、函数（function）是一种特殊的对象。
		
		
		
		
		
		
			3.input事件和change事件的区别
			
			input事件：输输入框内容发生改变时就会触发
			change事件：输入框内容发生改变，并且输入框失去焦点时触发。
		
		
		
		
			4. 变量 函数提升
			
			console.log(a); //undefined
			var a = 6; 
			
			js引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到到代码头部
			只有function声明的函数会发生函数名提升，而如果通过赋值语句写的函数则不会。
			
			fn(); //a
			function fn (){
				console.log("a");
			}
		
			
			
		
		
			5. 函数默认参数 
			
			function fn(param = 'hello') {
			    console.log(param);
			}
			方法被调用时，如果没有给参数赋值，那就是用默认值；
			方法被调用时，如果给参数赋值了新的值，那就用新的值。
			默认值的后面，不能再有没有默认值的变量。比如(a,b,c)这三个参数，如果我给 b 设置了默认值，那么就一定要给 c 设置默认值。
			
			
		
			
			
			
			
			6. 解构赋值
			
			1.解构对象
			const a = {
			      name: 'name',
			      age: 18,
			      marriage: false,
			    }
			let { name, age, marriage} = a;
			console.log(name, age, marriage)  打印信息：name 18 false
			
			2.解构数组
			let arr = [1,2,3];
			let [a,b,c] = arr;
			console.log(a); // 1
			
			
			
			
			
			
			
			
			7. 深拷贝，浅拷贝
			
			拷贝的时候并没有给b创造独立的内存，只是把a指向数据的 指针 拷贝给了b！
			
			原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。
			这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。
			这是因为 JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，不能接受函数。
			let objnew = JSON.parse(JSON.stringify(obj))
			
			//递归来实现深拷贝
			function deepClone(obj) {
				var newObj = obj instanceof Array ? [] : {};
				if (typeof obj !== 'object') {
					return obj;
				} else {
					for (var i in obj) {
						newObj[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
					}
				}
				return newObj;
			}
			var objnew = deepClone(obj)
			console.log(objnew)
				
				
				
				
				
				
				
			8. 扩展运算符
			
			let a = ["Bill","Mary","Lucy"];
			let b = [21,24,27];
			let c = [...a,...b];
			console.log(c);  // [ 'Bill', 'Mary', 'Lucy', 21, 24, 27 ]
			
			
			
			
			
			
			9. 类数组是什么和数组有什么区别
			
			相同点:都具有length属性和索引元素 
			不同点:类数组没有任何Array属性和Array方法(比如push)”
			let arr = document.querySelectorAll("div") 取到的是一个类数组 
			console.log(arr instanceof Array) 返回false
			Array.isArray(arr) 判断是不是数组返回false
			Array.from() 把类数组转为数组
			
			
			
			
			
			
			
			
			
			
			10. this的指向和 call与apply和bind区别
			https://blog.csdn.net/zwt13976124194/article/details/123384413
			
			1. 在普通函数中调用就是window
			window.username='程新松'
			function fn(){
			    console.log(this.username);
			}
			fn(); //程新松
			
		
			
			2. 对象里的this 哪个函数调用，this指向哪里。
			
			指向调用函数的那个对象 例如arr调用了a这个函数 this就是arr
			var arr = {
				b: 'ddd',
				a() {
					console.log(this.b)
				},	
			}
			arr.a();  //ddd
			
			
			
			3.箭头函数调用
			let obj={
			    name:'程新松',
			    fn:function(){
			        setTimeout(function(){console.log(this.name)})
			    }
			}
			obj.fn();
			不难发现，虽然 fn() 里面的 this 是指向 obj ，但是，传给 setTimeout 的是普通函数，
			this 指向是 window ， window 下面没有 name ，所以这里输出 underfind 。
			
			如果换成箭头函数
			这次输出 程新松 是因为，传给 setTimeout 的是箭头函数，然后箭头函数里面没有 this ，
			所以要向上层作用域查找，在这个例子上， setTimeout 的上层作用域是 fn 。而 fn 里面的 this 指向 obj ，
			所以 setTimeout 里面的箭头函数的 this ，指向 obj 。所以输出 程新松。
			
			
			
			
			4. call与apply和bind
			var a = {
			    user:"用户a",
			    fn:function(){
			        console.log(this.user); 
			    }
			}
			var b = {
				   user:"用户b"
			};
			
			a.fn.call(b);  //用户b
			把a对象里面的fn函数的指向 改成了b 
			 
			 a.fn.call(b,1,2); call里面还可以传别的参数 
			 a.fn.call(b,[1,2]);  apply其他参数必须是一个数组
			
			
			
			
			
			
			11. arguments
			arguments 是一个对应于传递给函数的参数的类数组对象 里面包含了函数所有的实参
			
			
			
			
			
			
			12. 防抖节流 
			https://www.lodashjs.com/
			函数防抖： 防抖就是回城被打断就要重来 
			将几次操作合并为一次操作进行。原理是维护一个定时器，规定在延迟时间后触发函数，只有最后一次操作能被触发。
			防抖:search联想搜索，用户在不断输入内容的时候，用防抖来节约请求资源。window触发resize时候，不断调整浏览器窗口大小会不断的触发这个事件，用防抖让其只触发一次。
			
			
			函数节流： 节流就是cd  cd没好 用不了技能
			使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。
			节流：鼠标不断点击（mousedown）触发，让其单位时间内只触发一次。
			
			
			
			13. 闭包
			
			//什么是闭包
			//闭包是嵌套的内部函数
			
			//产生闭包的条件
			//函数嵌套 内部函数引用了外部函数的变量 并且执行外部函数
			
			//闭包的作用
			//使函数内部的变量在函数执行完 没有消失 仍然存在
			//让函数外部 可以操作函数内部的数据
			
			function fun1() {         //外部函数fun1
				var a = 1;           //外部函数里有个变量 a=1
				function fun2() {    //内部函数 fun2
					console.log(a--) //内部函数里面用了外部函数的变量并且减1
				}
				return fun2           //外部函数的返回值是未执行的内部函数
			}
			
			
			var aaa = fun1(); //调用外部函数 获取外部函数的返回值并且存在aaa  此时的aaa就是内部函数 
			aaa(); //第一次调用内部函数
			aaa(); //第二次调用内部函数
			
			
			
			
			14. 如何优化内存泄漏?
			
			  全局变量先声明在使用
			  避免过多使用闭包。
			  注意清除定时器和事件监听器。
			  
			  
			  
			15. 构造函数和普通函数的区别 
			
				构造函数习惯上首字母大写
				构造函数用来新建实例对象
				a. 普通函数的调用方式：直接调用 person();
				b.构造函数的调用方式：需要使用new关键字来调用 new Person();
			
			
			
			
			
			
			
			16. 原型链 显示原型和隐式原型 
			
				1、所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）。
				2、所有的引用类型都有一个’_ _ proto_ _'属性(也叫隐式原型，它是一个普通的对象)。
				3、所有的函数都有一个’prototype’属性(这也叫显式原型，它也是一个普通的对象)。
				4、所有引用类型，它的’_ _ proto_ _'属性指向它的构造函数的’prototype’属性。
				5、当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _'属性(也就是它的构造函数的’prototype’属性)中去寻找。
		
			
				// 定义一个构造函数
				function Person(name,age){
					this.name = name;
					this.age = age;
				}
				
				// 创建一个构造函数的实例对象
				let person = new Person("张三",18)
				
				//构造函数的显示原型属性 拿到原型对象
				// console.log(Person.prototype) 
				
				//实例身上的隐式原型属性 拿到原型对象
				// console.log(person.__proto__)
				
				//通过显示原型属性往原型对象身上加一个x值是99
				Person.prototype.x = 99
				//person的原型对象身上就会有x这个属性
				console.log(person)
			
			
			
				17. promise async await
					
					1. promise是什么？
					Promise是JS中进行异步编程的新解决方案(ES6规范)
					Promise通过链式调用的解决方案，解决回调地狱问题
					
					2. Promise的状态有哪些?
					pendding(初始化状态，表示未发生改变)
					fulfilled(成功的状态）
					reject（失败的状态
					
					3. promise的状态和结果
					[[PromiseState]]: "fulfilled"
					[[PromiseResult]]: undefined

					
					4. 如何改变Promise状态?
					调用resolve或reject，每个Promise的状态只能修改一次
					
					5. 如何指定回调?
					首先获取promise实例对象，调用实例对象身上的.then()函数，并传入两个函数，
					第一个是成功的回调(resolve调用时执行)，第二个是失败的的回调(reject调用时执行)。 
					then可以只指定成功的回调，如果只指定失败的回调的话使用.catch(()=>{})其中传入失败的回调
					
					6. 如何执行回调?promise状态改变,即resolve或reject调用的时候自动执行
					
					Promise.resolve(value) 如果value是一个非Promise对象，则函数返回值是一个Promise对象，结果为value
					如果value是一个Promise对象，则返回值就是该Promise对象
					
					Promise.reject(reason) 返回一个失败的Promise对象，结果为reason
					
					Promise.all(promises) 返回一个新的promise，promises是一个包含多个promise的数组，
					当所有promise状态都为resolved，返回的promise状态才为resolved，状态为rejected
					
					Promise.race（promises） 返回一个新的promise，promises是一个包含多个promise的数组，
					只要有其中一个promise先改变状态，其状态就是返回的promise的状态，其结果就是返回的promise的结果。
					
					// 1.被async修饰过的函数 他的返回值就会是一个promise对象
					// 如果没有返回值就是fulfilled  
					// 如果返回的是一个字符串或者数字 这个函数的返回值就是promise对象 状态是成功 值就是这个函数的返回值
					// 如果返回的是一个promise对象 这个函数的返回值就是promise对象 状态是返回promise对象的状态 值就是这个是返回promise对象的值 throw也是一样
					
					// await 就是对右侧promise对象结果的一个获取
					// 如果右侧是一个数字或者字符串 结果就是对应的数字或字符串
					// 如果右侧是一个成功的promise对象 那么结果就是这个右侧promise对象的结果
					// 如果右侧是一个失败的promise对象 需要用try catch 里面的catch 来捕获这个promise对象失败的结果值
					
				
				
				
				
				
				
				18. localStorage与sessionStorage cookies token 
				
				localStorage语法：
				* 存数据：localStorage.setItem(‘属性名’,属性值）
				* 取数据：localStorage.getItem（‘属性名’）
				* 删数据：localStorage.removeItem('属性名‘）
				* 清空数据：localStorage.clear(）
				
				sessionStorage语法 :
				* 存数据：  sessionStorage.setItem('属性名',属性值)
				* 取数据:   sessionStorage.getItem('属性名')
				* 删数据:   sessionStorage.removeItem('属性名')
				* 清空数据: sessionStorage.clear()
				
				localStorage和sessionStorage的区别？
				相同点： 作用相同，都是存储数据
				不同点：存储方式不同
					localStorage   : 硬盘存储（永久存储）
					* 应用场景： 免登录
					sessionStorage : 内存存储 （临时存储）
					* 应用场景： 页面间传值
				
				.json语法 ？ ： 本质是字符串
				json转js :  let js对象 = JSON.parse(json格式)
				js转json :  let json格式 = JSON.stringify(js对象)
				
				
				
				token令牌
				当你们前后端分离之后，不使用session来保存状态的时候，就需要使用token来标识当前用户。
				通常是登录接口成功的时候会返回一个token给你，然后每次请求的时候在请求头中带上这个字段，
				后端就能根据这个字段知道是那个用户发起的请求了；如果你们还在使用session，那么你也就不用管什么token了
				
				
				
				cookies是什么
				浏览器存储 存的东西少 
				Cookie 是服务器保存在浏览器的一小段文本信息。浏览器每次向服务器发出请求，就会自动附上这段信息。
				
				
				
				
				
				
				19. 跨域问题
				
				浏览器的同源策略，规定当域名、端口、协议有一个不同，即为跨域。
				
				vue.config.js 里配置跨域
				//关闭校验工具
				module.exports = {
				    lintOnSave: false,
					//代理跨域
					devServer: {
					    proxy: {
					        '/api': {
					            target: "http://gmall-h5-api.atguigu.cn",
					        }
					    },
					},
				}
				
				
				
				
				
				
				
				20. 递归
				
				function fy(n) {
				    if (n == 1) {
				        return 1
				    } else {
				        return n + fy(n - 1)
				    }
						
				}
				console.log(fy(5));
				
				
				
				
				
				21. 随机数
				
				Math.floor(Math.random()*10+1) 表示结果为1-10之间的一个随机数
				
				ceil(x)	   对数进行上舍入，即向上取整。
				floor(x)	对 x 进行下舍入，即向下取整。
				round(x)	四舍五入。
				random()	返回 0 ~ 1 之间的随机数，包含 0 不包含 1。
				
				
				
				
				
				
				
				22. 事件对象
				
					//阻止冒泡
				  e.stopPropagation();
				  //阻止默认行为
				  e.preventDefault();
				
				
				
				
				
				23. 字符串方法 | 遍历
				
				indexOf('') 检索内容在字符串的位置 如果没有返回-1
				trim() 去左右空格
				substring() 方法用于提取字符串中介于两个指定下标之间的字符。
					string.substring(from, to)
					from 必需。一个非负的整数，规定要提取的子串的第一个字符在 string Object 中的位置。
					to 可选。一个非负的整数，比要提取的子串的最后一个字符在 string Object 中的位置多 1。
					如果省略该参数，那么返回的子串会一直到字符串的结尾。
				toLowerCase() 方法用于把字符串转换为小写。
				toUpperCase() 方法用于把字符串转换为大写。
				
				
				
				
				
				
				24. 数组方法  | 遍历
					
					1. 改变原数组 7个
					
					// 数组排序 会改变原数组 兼容ie
					let arr = [1,4,6,8,3,5,64,3];
					arr.sort(function(a,b){
						return a-b
					})
					console.log(arr)
					
					//  删除数组最后一个元素  删除第一个是shirt()
					var arr = ["Banana", "Orange", "Apple", "Mango"];
					// 接收那个删除的元素
					let arr2 = arr.pop()
					console.log(arr)   
					
					// 删除数组第一元素shirt()
					var arr = ["Banana", "Orange", "Apple", "Mango"];
					//接收那个删除的元素
					var arr2 = arr.shift()
					console.log(arr)
					
					//向数组的最后添加一个元素 	向数组第一位添加元素是 unshift()
					var arr = ["Banana", "Orange", "Apple", "Mango"];
					//返回的是新数组的长度
					var arr2 = arr.push("1")
					console.log(arr)
					
					//向数组第一位添加元素unshift()
					var arr = ["Banana", "Orange", "Apple", "Mango"];
					//返回的是新数组的长度
					var arr2 = arr.unshift("1")
					console.log(arr)
					
					//将数组中元素颠倒过来,该方法会改变原来的数组
					var arr = ["Banana", "Orange", "Apple", "Mango"];
					console.log(arr.reverse())
					
					//将数组从下标2开始删 删一位 
					var arr = ["1", "2", "3", "4"];
					arr.splice(2, 1);
					后面的参数是替换 那些被选中的下标
					var arr = ["1", "2", "3", "4"];
					arr.splice(2, 0, "5", "6");
				
				
				
				2. 不改变原数组
				
				 //合并数组 并返回一个新数组
				 var arr1 = [1,2];
				 var arr2 = [3,4];
				 var arr3 = [4,5];
				 var arr4 = arr1.concat(arr2, arr3);
				 console.log(arr4)
				 
				 //把数组转化为字符串 .join()里写分隔符 默认是,
				 let arr = [1,4,6,8,3,5,64,3];
				 let arr2 = arr.join()
				 console.log(arr2)
				 
				 //slice() 方法用数组的某个片段切出新数组。
				 var arr = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
				 //从数组元素 1 （"Orange"）开始切出一段数组：
				 var arr2 = arr.slice(1); 
				 //slice() 可接受两个参数，比如 (1, 3)。
				 //该方法会从开始参数选取元素，直到结束参数（不包括）为止
				 var arr3 = arr.slice(1,3); 
				 console.log(arr2)
				 
				 
				 // 子符串表示。返回值与没有参数的 join() 方法返回的字符串相同
				 var arr = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
				 var arr2 = arr.toString()
				 console.log(arr2)
				 
				 
				 
				 
				25. 数组的遍历
				 
				 forEach遍历所有数组 没有返回值
				var arr = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
				arr.forEach((item,index, arr) => {
					console.log(arr);
				})
				
				
				filter返回一个新的数组 通过筛选 return 满足筛选条件的数据，然后把所有满足条件的元素放进新的数组 把带n的返回装入一个新数组
				var newarr = arr.filter((currentValue,index, arr) => {
					return currentValue.indexOf("n") >= 0;
				})
				console.log(newarr);
				
				
				map类似于forEach 但是有返回值，return的是啥返回的新数组就是什么 不返回，默认是一个undefined元素的数组
				arr.map((currentValue,index, arr) => {
					console.log(currentValue + '------' + index);
					console.log(arr);
					return currentValue
				})
				
				
				some主要检测数组中的元素是否满足条件 返回一个布尔值，只返回一个满足条件的元素 如果找到第一个满足条件的元素，则终止循环
				var arr = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
				var flag =  arr.some((currentValue,index, arr) => {
					return currentValue.indexOf('Lasd') >= 0
				})
				console.log(flag)
				
				
				
				every 类似于some 但是some是遇到有满足条件的返回true 但是every是要求全部满足条件才返回true
				var flag = arr.every((currentValue,index, arr) => {
					return currentValue.charAt(0) === 'a'
				})
				console.log(flag);
				
				
				reduce() 返回的数据类型根据 return 后面的数据类型决定
				
				
				
				
				
				
				
				
				26. 对象方法 | 遍历
				
					合并对象
					var o = Object.assign(obj,obj1);
					
					获取对象的所有key组成的数组
					let a ={
						a:1,
						b:2
					}
					console.log(Object.keys(a))
					
					获取对象的所有value组成的数组
					let a ={
						a:1,
						b:2
					}
					console.log(Object.values(a))
					
					//遍历对象所有key和value
					let obj ={
						a:2,
						b:3
					}
					for(var i in obj){
						console.log(i +':'+ obj[i])
					}
				
				
				
				27. 什么是作用域，什么是作用域链？
				规定变量和函数的可使用范围称为作用域
				查找变量或者函数时，需要从局部作用域到全局作用域依次查找，这些作用域的集合称作用域链。
				
				 
				  
				 28.如何去判断js数据类型？
				 
				     首先我们可以用typeof去判断，typeof只能判断基本数据类型，对于引用数据类型，- -律返回object,
					 在js中，数组是一种特殊的对象类型， 因此typeof-个数组,返回的是object.
					 
					还可以通过instanceof来判断，它不能检测基本数据类型，它是用来判断个实例是否属于某种类型， 
					使用它的方式可以用A instanceof B，如果A是B的实例，则返回true,否则返回flase。
					
					let obj ={
						a:2,
						b:3
					}
					let arr = [1,2,3]
					console.log(obj instanceof Object)
					console.log(arr instanceof Array)
				        
				
				  
				  29.js中的堆内存与栈内存
				  
				  栈内存主要用于存储各种基本类型的变量，包括Boolean、Number、String、Undefined、Null，**以及对象变量的指针
				  占据空间小 大小固定 属于被频繁使用的数据 所有在栈中
				  
				  对于引用类型 当我们需要访问这三种引用类型的值时，首先得从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。
				  堆空间大 
				  
				  
				  
				  
				  
				  
				  30. js获取浏览器所用的内核
				  
				  var userAgentInfo = navigator.userAgent.toLowerCase();
				  	var isIE11 = !!window.ActiveXObject || "ActiveXObject" in window,
				  		isEdgeOld = navigator.userAgent.indexOf("Edge/") > -1,
				  		isEdgeNew = navigator.userAgent.indexOf("Edg/") > -1,
				  		isSafari = /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent),
				  		isUC = navigator.userAgent.indexOf('UCBrowser') > -1,
				  		isHW = userAgentInfo.indexOf("HuaweiBrowser") > -1,
				  		isFF = userAgentInfo.indexOf("Firefox") > -1,
				  		isWX = userAgentInfo.toLowerCase().match(/MicroMessenger/i) == 'micromessenger';
				  	var viewportWidth = document.documentElement.clientWidth,
				  		viewportHeight = document.documentElement.clientHeight,
				  		aspectRatio = viewportWidth / viewportHeight;
				  	var isMob = aspectRatio < 1.1,
				  		isMateX = aspectRatio < 1.1 && aspectRatio > 0.9;
				  	
				  
				  
				  31.null undefiend NaN的区别
				  
				  undefined一般表示根本”不存在“，
				  null表示定义了，但是值是”空“。
				  一般来说，当运算无法返回正确的数值时
				  let a = "b"
				  console.log(a*1) //NaN
				  
				  
				  
				  
				  32.DOM事件流和事件委托？
				  
				  DOM事件流：事件捕获、处于目标阶段、事件冒泡
				  （2）事件捕获阶段：事件从最上一级标签开始往下查找，直到捕获到事件目标(target)。
				  （3）事件冒泡阶段：事件从事件目标(target)开始，往上冒泡直到页面的最上一级标签
				  （4）事件委托以及好处：利用事件冒泡，指定一个事件处理程序，就可以管理某一类型的所有事件，动态添加事件，减少内存消耗
				 
				  
				  
				  33.ajax是什么？以及如何去创建它？
				  
				  ajax就是实现客户端和服务器端的异步通信 实现页面局部刷新
				  
					1.创建ajax对象
				   var xhr = new XMLHttpRequest();
				   2.连接服务器
				   xhr.open("get",url); 
				   3.发送请求
				   xhr.send();
					4.接收返回
				   xhr.onreadystatechange = function(){ 
					   if(xhr.readyState == 4 && xhr.status == 200){
								
						}
					},
				   
				  
				  
				  
				  
				  
				  
				  
				  
				  34.同步和异步的区别，分别列举一个同步和异步的例子？
				  
				  
				  javascript语言是一门“单线程”的语言，
				  同步任务指的是，在主线程上排队执行的任务 只有前一个任务执行完毕，才能执行后一个任务
				  异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，
				  只有等主线程任务执行完毕，"任务队列"开始通知主线程，请求执行任务，该任务才会进入主线程执行
				  
				  
				  
				  
				  35.什么是微任务和宏任务，两者有什么区别？
				  
				  微任务：process.nextTick、MutationObserver、Promise.then catch finally
				  宏任务：I/O、setTimeout、setInterval、setImmediate、requestAnimationFrame
				  
				  
				  
				  
				  
				  
				  
				  36. new一个实例的过程
				  
				  1. 创建一个新的对象obj
				  
				  2. 将对象与构造函数通过原型链连接起来
				  新对象的隐式原型__proto__指向new的构造函数的显示原型proptotype
				  
				  3. 将构造函数中的this绑定到新建的对象obj上
				  
				  4. 根据构造函数返回类型判断，如果是原始值则被忽略，如果返回对象，需要正常处理。
				  
				  
				  
				  
				  
				  
		
		
	</body>
</html>