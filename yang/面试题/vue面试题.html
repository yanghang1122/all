<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		
		

		
		1. v-show 与 v-if 区别
			“v-show”只编译一次；而“v-if”不停地销毁和创建
			v-show更适合于日常使用，可以减少数据的渲染
			vue-show本质就是标签display设置为none，控制隐藏
			vue-if是动态的向DOM树内添加或者删除DOM元素
			
			
			
			
		2. 动态绑定class的方法
			html部分：
			<div :class="{'active':isActive}"></div>
			
			js部分：判断是否绑定一个active
			data() {
			    return {
			      isActive: true
			    };
			}
			
			结果渲染为：
			<div class="active"></div>
			
			若要绑定多个class，需要逗号隔开就行：（这里的activeTwo加不加引号都可以，也一样都能渲染，如下）
			<div class="activeOne" v-bind:class="{ activeTwo: isActive, 'activeThree': hasError }"></div>
			https://blog.csdn.net/weixin_45449504/article/details/123069199
			
			
			
		
		
		
		3. 计算属性和 watch 的区别
			1、功能：computed是计算属性；watch是监听一个值的变化执行对应的回调
			2、是否调用缓存：computed函数所依赖的属性不变的时候会调用缓存；watch每次监听的值发生变化时候都会调用回调
			3、是否调用return：computed必须有；watch可以没有
			4、使用场景：computed当一个属性受多个属性影响的时候；例如购物车商品结算；watch当一条数据影响多条数据的时候，例如搜索框
			5、是否支持异步：computed函数不能有异步；watch可以
	
			computed计算属性
				在调用时候不加（）
				必须有return返回
				
				完整写法
				computed:{
					allname:{
						get(){
							return this.firstname + " - " + this.lastname;
						},
						set(e){
							let arr = e.split("-")
							this.firstname = arr[0]
							this.lastname = arr[1]
						}
					}
				}
				简写
				computed:{
					allname(){
						return this.firstname + " - " + this.lastname;
					}
				}
				
			watch监听	
				watch的函数名称必须和data中的数据名一致
				watch中的函数有两个参数，前者是newVal，后者是oldVal
				watch中的函数是不需要调用的
				watch只会监听数据的值是否发生改变，而不会去监听数据的地址是否发生改变，要深度监听需要配合deep：true属性使用
				immediate:true 页面首次加载的时候做一次监听
				可以监听计算属性 props 和data
				
				完整写法
				watch: {
					info: {
						immediate: true,
						deep: true,
						handler(val, oldval) {
							console.log("之前是：" + oldval + ",现在是：" + val)
						},
					},
				}
				简写
				watch: {
				   ishot(newValue,oldValue){
				       console.log('ishot被',newValue,oldValue);
					}
				}
	
				
		
			
		4. 怎样理解单向数据流
		prop也就是父组件传过来的数据，如果我们试图通过子组件的v-model去改变这个prop，也就是试图通过子组件直接去改变父组件的数据，而不是通过发送事件的方式，这是不允许的。
		也就是说，数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据的修改。
		这实际上是为了更好的解耦，在开发中如果有多个子组件依赖与父组件的某个数据，万一子组件真的可以直接修改父组件的数据，那么一个子组件的变化将会引发所有依赖于这个数据的子组件的变化，所以vue不推荐子组件直接修改父组件的数据，直接修改prop会抛出警告
		定义一个局部变量，并用prop的值初始化它
	
	
	
	
		
		
		5. 生命周期
		*   beforeCreate：创建前。此时，组件实例刚刚创建，还未进行数据观测和事件配置，拿不到任何数据。
		*   created：创建完成。vue 实例已经完成了数据观测，属性和方法的计算(比如props、methods、data、computed和watch此时已经拿得到)，但尚未开始挂载。
		*   beforeMount：挂载前。挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM）。编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。
		*   mounted：挂载完成。也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。
		*   beforeUpdate：在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，不会触发附加地重渲染过程。
		*   updated：更新后。在由于数据更改导致地虚拟DOM重新渲染和打补丁之后调用，
		*   beforeDestroy;销毁前。在实例销毁之前调用，实例仍然完全可用。（一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件）
		*   destroyed：销毁后。在实例销毁之后调用，调用后，vue实列指示的所有东西都会解绑，所有的事件监听器会被移除。
		
		vue3生命周期
		beforeCreate -> 使用 setup()
		created -> 使用 setup()
		beforeMount -> onBeforeMount
		mounted -> onMounted
		beforeUpdate -> onBeforeUpdate
		updated -> onUpdated
		beforeDestroy -> onBeforeUnmount
		destroyed -> onUnmounted
		errorCaptured -> onErrorCaptured
		
		其他：
		activated：在keep-alive组件激活时调用。
		deactivated：在keep-alive组件停用时
		
		
		
		
		
		6. vuex
		
			Vuex 是⼀个专为 Vue.js 应⽤程序开发的状态管理模式。每⼀个 Vuex 应⽤的核⼼就是 store（仓库）。
			“store” 基本上就是⼀个容器，它包含着你的应⽤中⼤部分的状态 ( state )。
			（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发⽣变化，那么相应的组件也会相应地得到⾼效更新。
			（2）改变 store 中的状态的唯⼀途径就是显式地提交 (commit) mutation。这样使得我们可以⽅便地跟踪每⼀个状态的变化。
			主要包括以下⼏个模块：
			State：定义了应⽤状态的数据结构，可以在这⾥设置默认的初始状态。
			Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
			Mutation：是唯⼀更改 store 中状态的⽅法，且必须是同步函数。
			Action：⽤于提交 mutation，⽽不是直接变更状态，可以包含任意异步操作。
			Module：允许将单⼀的 Store 拆分为多个 store 且同时保存在单⼀的状态树中
		
		
		

		
		
		7. <keep-alive include="缓存的是组件名 不写就是全部缓存"></keep-alive>包裹着<router-view></router-view> 不会被销毁
		
			include属性
			include 包含的意思。值为字符串或正则表达式或数组。只有组件的名称与include的值相同的才会被缓存，即指定哪些被缓存，可以指定多个被缓存。
			这里以字符串为例，指定多个组件缓存，语法是用逗号隔开。如下： <keep-alive include="home,about" >
			
			exclude属性
			exclude相当于include的反义词，就是除了的意思，指定哪些组件不被缓存，用法和include类似，如下：
			<keep-alive exclude="home,about" >
				
			使用了keep-alive的组件以后，组件上就会自动加上了activated钩子和deactivated钩子。
		
		
		
		
			8.this.$nextTick(()=>{
				
			})
			vue.js中this.$nextTick()就是起到了一个等待数据的作用，也就是说，将一些回调延迟，等到DOM更新之后再开始执行。简单点说，相当于setTimeout()的作用。
			1.你改变了dom元素数据，然后你又想输出dom，那你只能等到dom更新完成之后才会实现.
			2.通过事件改变data数据，然后输出dom，在方法里直接打印的话， 由于dom元素还没有更新， 
			因此打印出来的还是未改变之前的值，而通过this.$nextTick()获取到的值为dom更新之后的值.
			例子 通过文字点击切换文本然后自动获取焦点 就会用到
		
			
			9.slot插槽 三种 默认插槽 具名插槽 作用域插槽
			
			父级给子级传递结构 带名字就是具名插槽 没有名字就是作用域插槽
			在父级页面的子组件标签里写
			<template slot="jiegou">
				爹给你传的模板1
			</template>
			
			子级写slot
			<slot name="jiegou"></slot>
			
			
			作用域插槽:
			
			如果数据在子级就要写 作用域插槽
			在父组件可以拿到子组件的数据，通过子组件绑定数据传递给父组件。（插槽的作用域为子组件）
			
			子组件传递数据num
			<slot :num="num"></slot>
			
			父级使用
			<template scope="num">
				{{num.num}}
			</template>
			
			
			
			
		
		
		10. v-model 是怎样实现的
		
		v-model只是一个语法糖，等于:value+@input，真正的实现靠的还是： ﻿v-bind:绑定响应式数据，触发 input 事件并传递数据 (核心和重点)
		<input v-model="something">
		
		其实和下面一样的  input一般用于监听事件 只要输入的值变化了就会触发
		<input :value="something"  @input="something = $event.target.value">
		
		
		
		
		
		11. Vue.js 2.x 双向绑定原理
		
		vue数据的双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。
		其核心就是通过Object.defineProperty()方法设置set和get函数来实现数据的劫持,在数据变化时发布消息给订阅者,触发相应的监听回调。
		也就是说数据和视图同步,数据发生变化,视图跟着变化,视图变化,数据也随之发生改变;
		
		
		
		
		data为什么return一个对象
		8. 组件通信
		9. 路由跳转
		10. vue-router 有哪几种导航钩子
		12. 什么是 MVVM，与 MVC 有什么区别
		15. vue的原理
		16. 理解Vue中的Render渲染函数
		权限
		
		
		
		
		
		
	</body>
</html>
