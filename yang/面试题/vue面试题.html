<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>




		1. v-show 与 v-if 区别
		“v-show”只编译一次；而“v-if”不停地销毁和创建
		v-show更适合于日常使用，可以减少数据的渲染
		vue-show本质就是标签display设置为none，控制隐藏
		vue-if是动态的向DOM树内添加或者删除DOM元素




		2. 动态绑定class的方法
		html部分：
		<div :class="{'active':isActive}"></div>

		js部分：判断是否绑定一个active
		data() {
		return {
		isActive: true
		};
		}

		结果渲染为：
		<div class="active"></div>

		若要绑定多个class，需要逗号隔开就行：（这里的activeTwo加不加引号都可以，也一样都能渲染，如下）
		<div class="activeOne" v-bind:class="{ activeTwo: isActive, 'activeThree': hasError }"></div>
		https://blog.csdn.net/weixin_45449504/article/details/123069199






		3. 计算属性和 watch 的区别
		1、功能：computed是计算属性；watch是监听一个值的变化执行对应的回调
		2、是否调用缓存：computed函数所依赖的属性不变的时候会调用缓存；watch每次监听的值发生变化时候都会调用回调
		3、是否调用return：computed必须有；watch可以没有
		4、使用场景：computed当一个属性受多个属性影响的时候；例如购物车商品结算；watch当一条数据影响多条数据的时候，例如搜索框
		5、是否支持异步：computed函数不能有异步；watch可以

		computed计算属性
		在调用时候不加（）
		必须有return返回

		完整写法
		computed:{
		allname:{
		get(){
		return this.firstname + " - " + this.lastname;
		},
		set(e){
		let arr = e.split("-")
		this.firstname = arr[0]
		this.lastname = arr[1]
		}
		}
		}
		简写
		computed:{
		allname(){
		return this.firstname + " - " + this.lastname;
		}
		}

		watch监听
		watch的函数名称必须和data中的数据名一致
		watch中的函数有两个参数，前者是newVal，后者是oldVal
		watch中的函数是不需要调用的
		watch只会监听数据的值是否发生改变，而不会去监听数据的地址是否发生改变，要深度监听需要配合deep：true属性使用
		immediate:true 页面首次加载的时候做一次监听
		可以监听计算属性 props 和data

		完整写法
		watch: {
		info: {
		immediate: true,
		deep: true,
		handler(val, oldval) {
		console.log("之前是：" + oldval + ",现在是：" + val)
		},
		},
		}
		简写
		watch: {
		ishot(newValue,oldValue){
		console.log('ishot被',newValue,oldValue);
		}
		}




		4. 怎样理解单向数据流
		prop也就是父组件传过来的数据，如果我们试图通过子组件的v-model去改变这个prop，也就是试图通过子组件直接去改变父组件的数据，而不是通过发送事件的方式，这是不允许的。
		也就是说，数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据的修改。
		这实际上是为了更好的解耦，在开发中如果有多个子组件依赖与父组件的某个数据，万一子组件真的可以直接修改父组件的数据，那么一个子组件的变化将会引发所有依赖于这个数据的子组件的变化，所以vue不推荐子组件直接修改父组件的数据，直接修改prop会抛出警告
		定义一个局部变量，并用prop的值初始化它






		5. 生命周期
		* beforeCreate：创建前。此时，组件实例刚刚创建，还未进行数据观测和事件配置，拿不到任何数据。
		* created：创建完成。vue 实例已经完成了数据观测，属性和方法的计算(比如props、methods、data、computed和watch此时已经拿得到)，但尚未开始挂载。
		* beforeMount：挂载前。挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM）。编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。
		* mounted：挂载完成。也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。
		* beforeUpdate：在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，不会触发附加地重渲染过程。
		* updated：更新后。在由于数据更改导致地虚拟DOM重新渲染和打补丁之后调用，
		* beforeDestroy;销毁前。在实例销毁之前调用，实例仍然完全可用。（一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件）
		* destroyed：销毁后。在实例销毁之后调用，调用后，vue实列指示的所有东西都会解绑，所有的事件监听器会被移除。

		vue3生命周期
		beforeCreate -> 使用 setup()
		created -> 使用 setup()
		beforeMount -> onBeforeMount
		mounted -> onMounted
		beforeUpdate -> onBeforeUpdate
		updated -> onUpdated
		beforeDestroy -> onBeforeUnmount
		destroyed -> onUnmounted
		errorCaptured -> onErrorCaptured

		其他：
		activated：在keep-alive组件激活时调用。
		deactivated：在keep-alive组件停用时





		6. vuex

		Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。
		“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。
		（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
		（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。
		主要包括以下几个模块：
		State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
		Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
		Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
		Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
		Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中






		7. <keep-alive include="缓存的是组件名 不写就是全部缓存"></keep-alive>包裹着<router-view></router-view> 不会被销毁

		include属性
		include 包含的意思。值为字符串或正则表达式或数组。只有组件的名称与include的值相同的才会被缓存，即指定哪些被缓存，可以指定多个被缓存。
		这里以字符串为例，指定多个组件缓存，语法是用逗号隔开。如下： <keep-alive include="home,about">

			exclude属性
			exclude相当于include的反义词，就是除了的意思，指定哪些组件不被缓存，用法和include类似，如下：
			<keep-alive exclude="home,about">

				使用了keep-alive的组件以后，组件上就会自动加上了activated钩子和deactivated钩子。




				8.this.$nextTick(()=>{

				})
				vue.js中this.$nextTick()就是起到了一个等待数据的作用，也就是说，将一些回调延迟，等到DOM更新之后再开始执行。简单点说，相当于setTimeout()的作用。
				1.你改变了dom元素数据，然后你又想输出dom，那你只能等到dom更新完成之后才会实现.
				2.通过事件改变data数据，然后输出dom，在方法里直接打印的话， 由于dom元素还没有更新，
				因此打印出来的还是未改变之前的值，而通过this.$nextTick()获取到的值为dom更新之后的值.
				例子 通过文字点击切换文本然后自动获取焦点 就会用到


				9.slot插槽 三种 默认插槽 具名插槽 作用域插槽

				父级给子级传递结构 带名字就是具名插槽 没有名字就是作用域插槽
				在父级页面的子组件标签里写
				<template slot="jiegou">
					爹给你传的
				</template>

				子级写slot
				<slot name="jiegou"></slot>


				作用域插槽:

				如果数据在子级就要写 作用域插槽
				在父组件可以拿到子组件的数据，通过子组件绑定数据传递给父组件。（插槽的作用域为子组件）

				子组件传递数据num
				<slot :num="num"></slot>

				父级使用
				<template scope="num">
					{{num.num}}
				</template>






				10. v-model 是怎样实现的

				v-model只是一个语法糖，等于:value+@input，真正的实现靠的还是： ﻿v-bind:绑定响应式数据，触发 input 事件并传递数据 (核心和重点)
				<input v-model="something">

				其实和下面一样的 input一般用于监听事件 只要输入的值变化了就会触发
				<input :value="something" @input="something = $event.target.value">





				11. Vue.js 2.x 双向绑定原理

				vue数据的双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。
				其核心就是通过Object.defineProperty()方法设置set和get函数来实现数据的劫持,在数据变化时发布消息给订阅者,触发相应的监听回调。
				也就是说数据和视图同步,数据发生变化,视图跟着变化,视图变化,数据也随之发生改变;
				
				let obj = {}
				// 给obj的name属性设置两个方法get&set
				Object.defineProperty(obj,'name',{
				set:function (value){ //value就是给name赋值的结果
				console.log('触发了set');
				this._name=value//保存这个值 这里不能直接用name,因为会触发set
				},
				get:function(){
				console.log('触发了get');
				// 将保存的值返回回来
					return this._name
				}
				})






				12. data为什么return一个对象
				
				如果是以对象中的数据返回的话，组件之中会共用同一块内存，在一个组件中修改数据，另一个组件也会受到影响，
				以函数 return 出去的形式，每次 return 都会重新开辟内存，各个组件中得 data 也就没有任何关系
				总的来说，就是为了保证各个子组件之间的数据独立性。
				
				
				
				13. 组件通信
				
					1. 父 >>> 子  （Props）
					父组件可以使用 props 把数据传给子组件。
					 <children :message="toChildrenMsg"></children>
					  props:{
					         message:{
					             type:String,  //类型判断
					             default:''    //默认值
					         }
					     }
					
					
					2. 子 >>> 父 （$emit）
					子组件可以使用 $emit 触发父组件的自定义事件。
					<button @click='select'>点击此处将‘大连’发射给父组件</button>
					 methods:{
					      select() {
					        this.$emit('showCityName',this.num);//select事件触发后，自动触发showCityName事件
					      }
					    }
					<children  @showCityName="updateCity"></children>
					 methods:{
					      updateCity(data){//触发子组件城市选择-选择城市的事件
					        console.log(data)
					      }
					    }
						
						
					3.全局事件总线
					main.js里面将该bus作为当前Vue实例的原型方法，能直接在各组件里面通过this.bus的方式调用
					首先是初始化一个eventBus，可以绑定到vue原型上，也可以绑定到window对象上，
					还可以抽出来当做一个模块，在需要的时候再引入。这里直接绑定到vue原型上：、
					切记：触发、监听名称必须相同！
					
					beforeCreate(){
						 Vue.prototype.bus = this
					 }
					
					在想要接受参数的页面通过.$on创建一个事件 $off删除一个事件
					mounted(){
					    this.bus.$off('toChild')
					    this.bus.$on('toChild',(val)=>{   
					       this.fromParentMsg = val    //此处为复制操作，也可在里面执行相应的方法
					    })
					}
						
						在需要的地方触发事件
						methods:{
						     toChildBus(){
						         let val = '父组件向子组件通信'
						         this.bus.$emit('toChild',val) //val为传过去的值，非必传
						     }
						 }
				
				
				4.Vuex状态管理库
				this.$store.state.xxx，直接对state进行操作
				存
				mounted(){
				        this.$store.state.msg = '父组件存入'    //在此处通过方式一存起来
				}
				取
				methods:{
					 fromStore(){
					     this.fromStoreMsg = this.$store.state.msg
					}
				}
				
				通过this.$store.getters.xxx、mapGetters进行取出。
				getters:{
				    getMsg:state=>{
						return state.msg
				    }
				},
				
				//也可以用mapGetters的方式
				import { mapGetters } from 'vuex'
				computed: {
					...mapGetters(['getMsg'])
				},
				
				mapState用法
				import { mapState } from 'vuex'
				computed: {
					...mapState(['getMsg'])
				},
					
				
				5、Router
				可以通过动态路由、路由跳转方式进行传值，如this.$router.push({path:'xxx',query:{value:'xxx'}})，
				在跳转的时候顺便传值，通过this.$route.params.value和this.$route.query.value获取到传过来的参数。
				该方式有局限性，只能在相互跳转的组件通信取值，且直接在跳转之后的页面进行刷新取不到值，视情况而用。
				
				
				6、缓存
				 sessionStorage、localStorage、cookie
				多个组件之间的通信除了可以用bus、store之外，还比较一种常用的方式--缓存，在同一个窗口不关闭的情况下，该窗口下的其他组件都可以取到缓存中已经存好的值，
				利用sessionStorage.setItem(key,value)、localStorage.setItem(key,value)等将值存起来，
				其他组件可以通过sessionStorage.getItem(key)、localStorage.getItem(key)等方式拿到，
				多个页面共享缓存数据，刷新页面数据不会销毁，可以用sessionStorage.removeItem(key)、localStorage.removeItem(key)的方式将缓存移除，可用场景还是比较多的。
				
				
			
				
				14. 路由跳转
				
				https://blog.csdn.net/m0_46293001/article/details/123099883
				
				
				
				
				
				
				
				
				
				
				10. vue-router 有哪几种导航钩子
				12. 什么是 MVVM，与 MVC 有什么区别
				15. vue的原理
				16. 理解Vue中的Render渲染函数
				路由守卫
				权限






	</body>
</html>
