<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		
			1.var、let、const 的区别?
		
			var 声明的变量有变量提升的特性，而 let、const 没有
			var 声明的变量会挂载到 windows 对象上，所以使用 var 声明的是全局变量，而 let 和 const 声明的变量是局部变量, 块级作用域外不能访问
			同一作用域下 let 和 const 不能重复声明同名变量，而var可以
			const声明的是常量，必须赋初值，一旦声明不能再次赋值修改，如果声明的是复合类型数据，可以修改其属性
		
		
		
		
		
			2.js中的基础数据类型有哪几种? 
			
			Javascript数据类型分为基本数据类型与引用数据类型，其中基本数据类型为：
			字符串（String）、数字(Number)、布尔(Boolean)、、空值（Null）、未定义（Undefined）、symbol。
			引用数据，类型为对象(Object)，其中数组(Array)、函数（function）是一种特殊的对象。
		
		
		
		
		
		
			3.input事件和change事件的区别
			
			input事件：输输入框内容发生改变时就会触发
			change事件：输入框内容发生改变，并且输入框失去焦点时触发。
		
		
		
		
			4. 变量 函数提升
			
			console.log(a); //undefined
			var a = 6; 
			
			js引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到到代码头部
			只有function声明的函数会发生函数名提升，而如果通过赋值语句写的函数则不会。
			
			fn(); //a
			function fn (){
				console.log("a");
			}
		
			
			
		
		
			5. 函数默认参数 
			
			function fn(param = 'hello') {
			    console.log(param);
			}
			方法被调用时，如果没有给参数赋值，那就是用默认值；
			方法被调用时，如果给参数赋值了新的值，那就用新的值。
			默认值的后面，不能再有没有默认值的变量。比如(a,b,c)这三个参数，如果我给 b 设置了默认值，那么就一定要给 c 设置默认值。
			
			
		
			
			
			
			
			6. 解构赋值
			
			1.解构对象
			const a = {
			      name: 'name',
			      age: 18,
			      marriage: false,
			    }
			let { name, age, marriage} = a;
			console.log(name, age, marriage)  打印信息：name 18 false
			
			2.解构数组
			let arr = [1,2,3];
			let [a,b,c] = arr;
			console.log(a); // 1
			
			
			
			
			
			
			
			
			
			
			7. 深拷贝，浅拷贝
			
			拷贝的时候并没有给b创造独立的内存，只是把a指向数据的 指针 拷贝给了b！
			
			原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。
			这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。
			这是因为 JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，不能接受函数。
			let objnew = JSON.parse(JSON.stringify(obj))
			
			//递归来实现深拷贝
			function deepClone(obj) {
				var newObj = obj instanceof Array ? [] : {};
				if (typeof obj !== 'object') {
					return obj;
				} else {
					for (var i in obj) {
						newObj[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
					}
				}
				return newObj;
			}
			var objnew = deepClone(obj)
			console.log(objnew)
				
				
				
				
				
				
				
			8. 扩展运算符
			
			let a = ["Bill","Mary","Lucy"];
			let b = [21,24,27];
			let c = [...a,...b];
			console.log(c);  // [ 'Bill', 'Mary', 'Lucy', 21, 24, 27 ]
			
			
			
			
			
			9. this的指向
			https://www.cnblogs.com/chengxs/p/8679313.html
			
			
			
			
			
			
			
			
			
				迭代器
				生成器
				iterator接口
				promise async await then 方法
				js继承
				
				防抖节流 
				
				
				数组的方法 那些方法改变原数组 filter  concat 改7个 
				math. 随机数
				构造函数和函数的区别 实例化对象是什么意思
				原型链 显示原型和隐式原型 
				闭包
				session cookies token 
				跨域问题
				递归
				5. 如何优化内存泄漏?
				
				  全局变量先声明在使用
				  避免过多使用闭包。
				  注意清除定时器和事件监听器。
				  
				  
				
		
		
		https://blog.csdn.net/m0_65450343/article/details/124658549
		https://blog.csdn.net/Amrice_/article/details/123086495
		https://wenku.baidu.com/view/c09d3d42834d2b160b4e767f5acfa1c7aa008282.html
		
		
		
				
		
		
		
	</body>
</html>